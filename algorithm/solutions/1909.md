# 19년 9월 문제

## 두번째 문제

### 문제 소개

아주 큰 수가 주어졌을 때(10의 18승 이하), 이 수가 2의 N제곱수인지를 판별해 내는 문제이다.

### 내가 푼 방법

```cpp
#include <iostream>

using namespace std;
int main() {
    unsigned long long  N;
    cin >> N;
    while (N != 1) {
        if (N % 2) {
            cout << "No";
            return 0;
        }
        N /= 2;
    }
    cout << "Yes";

}
```

### 설명

모든 수는 2로 계속 나누어 가다 보면 언젠가는 1이 된다. 1이 되기 전에 한 번이라도 홀수가 나오게 되면 이 수는 2의 N제곱일 수가 없다. 이 원리를 이용해서 홀수가 나오게 되는 순간 `No`를 찍고 프로그램을 종료한다.

### 더 나은 풀이

기억해야 할 것이 있다. 2의 N제곱 문제가 등장한다면 언제나 비트 연산자를 생각하는 것이 좋다.  
알아두어야 할 정보는 다음과 같다.

1. 2의 N제곱수는 2진수로 나타냈을 때 `1`이 단 한 번 등장한다.
2. 비트연산자 `-`는 0을 1로, 1을 0으로 바꾸고 1을 더한다.(2의 보수 참고)
3. 비트연산자 `&`는 두 비트가 모두 1일 때에만 1을 return하고 나머지 경우에 대해서는 0을 return한다.

`1000101010010101` 라는 숫자가 있다고 해보자. 이 값이 무엇인지는 중요치 않다. 이 숫자 `-` 연산자를 사용하면 `0111010101101011`이 된다. 얘와 원래 숫자를 `&`연산을 해주면
`0000000000000001`을 얻을 수 있다. 즉, 제일 마지막에 등장하는 1만 남게 된 것이다. 이 원리를 이용해서 마지막에 등장하는 1(2의 N제곱수라면 유일한 1이기도 함)과 원래의 수가 같다면 2의 제곱수라고 확신할 수 있는 것이다.

```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    unsigned long long  N;
    cin >> N;
    string val = (N == ((-N) & N)) ? "Yes" : "No";
    cout << val;
}
```
